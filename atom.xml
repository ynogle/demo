<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://ynogle.github.io/atom.xml" rel="self"/>
  
  <link href="https://ynogle.github.io/"/>
  <updated>2020-08-23T10:50:36.000Z</updated>
  <id>https://ynogle.github.io/</id>
  
  <author>
    <name>Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://ynogle.github.io/2020/08/23/hexo%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <id>https://ynogle.github.io/2020/08/23/hexo%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-23T12:18:41.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo资源优化</p><p>1.hexo-neat<br>npm install hexo-neat –save</p><p>项目配置文件下添加</p><h1 id="hexo-neat"><a href="#hexo-neat" class="headerlink" title="hexo-neat"></a>hexo-neat</h1><h1 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h1><p>neat_enable: true</p><h1 id="压缩html"><a href="#压缩html" class="headerlink" title="压缩html"></a>压缩html</h1><p>neat_html:<br>  enable: true<br>  exclude:</p><h1 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h1><p>neat_css:<br>  enable: true<br>  exclude:<br>    - ‘**&#x2F;*.min.css’</p><h1 id="压缩js"><a href="#压缩js" class="headerlink" title="压缩js"></a>压缩js</h1><p>neat_js:<br>  enable: true<br>  mangle: true<br>  output:<br>  compress:<br>  exclude:<br>    - ‘<strong>&#x2F;*.min.js’<br>    - ‘</strong>&#x2F;jquery.fancybox.pack.js’<br>    - ‘**&#x2F;index.js’ </p><ol start="2"><li>gulp<br>sudo npm install –global gulp –unsafe-perm<br>npm install gulp-minify-html gulp-minify-css gulp-uglify gulp-imagemin<br>npm install gulp-terser –save-devclear<br>项目根目录添加gulpfile.js</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo资源优化&lt;/p&gt;
&lt;p&gt;1.hexo-neat&lt;br&gt;npm install hexo-neat –save&lt;/p&gt;
&lt;p&gt;项目配置文件下添加&lt;/p&gt;
&lt;h1 id=&quot;hexo-neat&quot;&gt;&lt;a href=&quot;#hexo-neat&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ynogle.github.io/2020/08/23/debian8%E4%BB%A5%E4%B8%8A%E5%AE%89%E8%A3%85%20v2ray/"/>
    <id>https://ynogle.github.io/2020/08/23/debian8%E4%BB%A5%E4%B8%8A%E5%AE%89%E8%A3%85%20v2ray/</id>
    <published>2020-08-23T12:18:40.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>debian8以上安装 v2ray（vmess+websocket+TLS+Caddy）<br>修改时区<br>rm -rf &#x2F;etc&#x2F;localtime #先删除默认的时区设置<br>ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime #替换上海&#x2F;北京作为默认<br>同步时间<br>apt-get install ntpdate -y<br>ntpdate us.pool.ntp.org</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;debian8以上安装 v2ray（vmess+websocket+TLS+Caddy）&lt;br&gt;修改时区&lt;br&gt;rm -rf &amp;#x2F;etc&amp;#x2F;localtime #先删除默认的时区设置&lt;br&gt;ln -s &amp;#x2F;usr&amp;#x2F;share&amp;#x2F;zo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git 即时全局更新忽略文件的方法</title>
    <link href="https://ynogle.github.io/2019/09/17/git%20%E6%9B%B4%E6%96%B0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/"/>
    <id>https://ynogle.github.io/2019/09/17/git%20%E6%9B%B4%E6%96%B0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</id>
    <published>2019-09-17T05:35:27.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>git 即时全局更新忽略文件的方法。<span id="more"></span></p><hr><p>git 更新忽略文件步骤：</p><ol><li>将准备好的忽略文件（.gitignore）放至项目根目录。</li><li>清空缓存 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure></li><li>重新添加  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>提交更新信息 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;update .gitignore&quot;</span></span><br></pre></td></tr></table></figure></li><li>同步至远端 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;git 即时全局更新忽略文件的方法。</summary>
    
    
    
    <category term="Git" scheme="https://ynogle.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://ynogle.github.io/tags/Git/"/>
    
    <category term="git" scheme="https://ynogle.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac 使用 ssh-key 形式免密码登录服务器</title>
    <link href="https://ynogle.github.io/2019/06/04/%E9%80%9A%E8%BF%87%20ssh-key%20%E5%BD%A2%E5%BC%8F%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://ynogle.github.io/2019/06/04/%E9%80%9A%E8%BF%87%20ssh-key%20%E5%BD%A2%E5%BC%8F%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2019-06-04T02:45:23.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常来说，我们使用 ssh user@host -p port，并输入密码。才能登陆到服务器进行管理。每次都重复着输入一长串的命令。好在 Unix 系的操作系统提供了各种 ssh 支持。我们可以通过简化命令输入达到节省时间的目的。<span id="more"></span></p><hr><p>假设我们有一台服务器，主机名为：host，ip为：8.8.8.8，账号为：ynogle，密码为：123，ssh 端口为：8089。一般的连接方式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh ynogle@8.8.8.8 -p 8089</span><br><span class="line">password:123</span><br></pre></td></tr></table></figure><p>不仅很麻烦，还要记忆 IP 和端口。假如，我们有很多台服务器。当我们面对这些命令的时候，累觉不爱啊（：。</p><p>ssh 有自己的配置文件。通过编辑 ~&#x2F;.ssh&#x2F;config 将服务器地址、端口号、用户配置成一个别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host host</span><br><span class="line">HostName 8.8.8.8</span><br><span class="line">Port 8089</span><br><span class="line">User ynogle</span><br></pre></td></tr></table></figure><p>保存之后，就可以通过别名的方式来登录服务器了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br><span class="line">password: 123</span><br></pre></td></tr></table></figure><p>虽然我们通过别名的方式已经大大简化了登录的步骤。但是，我们还得手动的输入密码。为了进一步简化登录步骤我们可以通过配置密钥的方式来通过 ssh key 登录，从而最大化的简化登录步骤。</p><p>首先，生成公钥和私钥。在本地终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>如果不需要为密钥设置密码，一直回车即可。创建结束后，会在 ~&#x2F;.ssh 目录中生成 id_rsa（私钥） 和 id_rsa.pub（公钥）两个文件。接下来，我们需要将公钥（id_rsa.pub）上传到 host 服务器的 ~&#x2F;.ssh 目录下。然后，将文件传输到 host 服务器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub host:~/.ssh/</span><br></pre></td></tr></table></figure><p>传输完成之后，登录到 host 服务器。在 ~&#x2F;.ssh 目录下，将 id_rsa.pub 更名为 authorized_keys：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ <span class="built_in">mv</span> id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><p>然后，为 ssh 文件配置权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> 700 ~/.ssh/</span><br><span class="line">$ <span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>最后，别忘了检查 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 中的 PubkeyAuthentication 权限是否是 yes 开启状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>如果，是未开启状态。修改为 PubkeyAuthentication yes 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># 端口</span><br><span class="line">Port 22</span><br><span class="line"># 允许 root 登录</span><br><span class="line">permitRootLogin yes</span><br><span class="line"># 公钥登录验证</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"># 密码登录验证</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以设置只允许 root 用户登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> /etc/nologin</span><br></pre></td></tr></table></figure><p>取消只允许 root 用户登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf /etc/nologin</span><br></pre></td></tr></table></figure><p>然后，重启 ssh 服务：<br>CentOS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart sshd</span><br></pre></td></tr></table></figure><p>Debian&#x2F;Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>现在，我们可以本地终端使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br></pre></td></tr></table></figure><p>登录到 host 服务器了。不需要输入密码，再也不需要记那些烦人的服务器参数了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常来说，我们使用 ssh user@host -p port，并输入密码。才能登陆到服务器进行管理。每次都重复着输入一长串的命令。好在 Unix 系的操作系统提供了各种 ssh 支持。我们可以通过简化命令输入达到节省时间的目的。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="ssh" scheme="https://ynogle.github.io/tags/ssh/"/>
    
    <category term="server" scheme="https://ynogle.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>转秋水逸冰 一键安装最新内核并开启 BBR 脚本</title>
    <link href="https://ynogle.github.io/2019/05/28/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AF%20BBR%20%E8%84%9A%E6%9C%AC/"/>
    <id>https://ynogle.github.io/2019/05/28/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AF%20BBR%20%E8%84%9A%E6%9C%AC/</id>
    <published>2019-05-28T09:45:10.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。<span id="more"></span></p><p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。<br>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。<br>于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR 脚本。</p><hr><p>本脚本适用环境<br>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等<br>内存要求：≥128M<br>日期　　：2018 年 12 月 14 日</p><p>关于本脚本<br>1、本脚本已在 Vultr 上的 VPS 全部测试通过。<br>2、当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。<br>3、脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。<br>4、由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。</p><hr><h3 id="Debian-Ubuntu-环境"><a href="#Debian-Ubuntu-环境" class="headerlink" title="Debian&#x2F;Ubuntu 环境"></a>Debian&#x2F;Ubuntu 环境</h3><p>使用方法<br>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; <span class="built_in">chmod</span> +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>查看内核版本，显示为最新版就表示 OK 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>返回值一般为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class="line">或者为：</span><br><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>返回值一般为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure><p>返回值一般为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p><hr><h3 id="CentOS-环境"><a href="#CentOS-环境" class="headerlink" title="CentOS 环境"></a>CentOS 环境</h3><p>CentOS 下最新版内核 headers 安装方法<br>本来打算在脚本里直接安装 kernel-ml-headers，但会出现和原版内核 headers 冲突的问题。因此在这里添加一个脚本执行完后，手动安装最新版内核 headers 之教程。<br>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>根据 CentOS 版本的不同，此时一般会出现类似于以下的错误提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-2.6.32-696.20.1.el6.x86_64</span><br><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-3.10.0-693.17.1.el7.x86_64</span><br></pre></td></tr></table></figure><p>因此需要先卸载原版内核 headers ，然后再安装最新版内核 headers。执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove kernel-headers</span><br></pre></td></tr></table></figure><p>确认无误后，输入 y，回车开始卸载。注意，有时候这么操作还会卸载一些对内核 headers 依赖的安装包，比如 gcc、gcc-c++ 之类的。不过不要紧，我们可以在安装完最新版内核 headers 后再重新安装回来即可。<br>卸载完成后，再次执行上面给出的安装命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>成功安装后，再把那些之前对内核 headers 依赖的安装包，比如 gcc、gcc-c++ 之类的再安装一次即可。</p><p>为什么要安装最新版内核 headers 呢？<br>这是因为 shadowsocks-libev 版有个 tcp fast open 功能，如果不安装的话，这个功能是无法开启的。</p><p>内核升级方法<br>如果是 CentOS 系统，执行如下命令即可升级内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install kernel-ml kernel-ml-devel</span><br></pre></td></tr></table></figure><p>如果你还手动安装了新版内核 headers ，那么还需要以下命令来升级 headers ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>CentOS 6 的话，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/^default=.*/default=0/g&#x27;</span> /boot/grub/grub.conf</span><br></pre></td></tr></table></figure><p>CentOS 7 的话，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grub2-set-default 0</span><br></pre></td></tr></table></figure><p>如果是 Debian&#x2F;Ubuntu 系统，则需要手动下载最新版内核来安装升级。<br>去这里下载最新版的内核 deb 安装包。<br>如果系统是 64 位，则下载 amd64 的 linux-image 中含有 generic 这个 deb 包；<br>如果系统是 32 位，则下载 i386 的 linux-image 中含有 generic 这个 deb 包；<br>安装的命令如下（以最新版的 64 位 4.12.4 举例而已，请替换为下载好的 deb 包）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -i linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb</span><br></pre></td></tr></table></figure><p>安装完成后，再执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/sbin/update-grub</span><br></pre></td></tr></table></figure><p>最后，重启 VPS 即可。</p><p>特别说明<br>如果你使用的是 Google Cloud Platform （GCP）更换内核，有时会遇到重启后，整个磁盘变为只读的情况。只需执行以下命令即可恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o remount rw /</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="BBR" scheme="https://ynogle.github.io/tags/BBR/"/>
    
  </entry>
  
  <entry>
    <title>转秋水逸冰 CentOS 下 libev 一键安装脚本</title>
    <link href="https://ynogle.github.io/2019/05/28/Centos%20%E4%B8%8B%20libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/"/>
    <id>https://ynogle.github.io/2019/05/28/Centos%20%E4%B8%8B%20libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</id>
    <published>2019-05-28T09:22:58.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。<span id="more"></span></p><hr><p>本脚本适用环境：<br>系统支持：CentOS<br>内存要求：≥128M<br>更新日期：2018 年 06 月 01 日</p><p>关于本脚本：<br>一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</p><p>默认配置：<br>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）</p><p>Shadowsocks for Windows 客户端下载：<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>使用方法：<br>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh</span><br><span class="line">$ <span class="built_in">chmod</span> +x shadowsocks-libev.sh</span><br><span class="line">$ ./shadowsocks-libev.sh 2&gt;&amp;1 | <span class="built_in">tee</span> shadowsocks-libev.log</span><br></pre></td></tr></table></figure><p>安装完成后，脚本提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, Shadowsocks-libev server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/357.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>卸载方法：<br>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./shadowsocks-libev.sh uninstall</span><br></pre></td></tr></table></figure><p>安装完成后即已后台启动 Shadowsocks-libev ，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><p>可以查看进程是否启动。<br>本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。</p><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">启动：</span><br><span class="line">$ /etc/init.d/shadowsocks start</span><br><span class="line"></span><br><span class="line">停止：</span><br><span class="line">$ /etc/init.d/shadowsocks stop</span><br><span class="line"></span><br><span class="line">重启：</span><br><span class="line">$ /etc/init.d/shadowsocks restart</span><br><span class="line"></span><br><span class="line">查看状态：</span><br><span class="line">$ /etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure><p>配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;server&quot;:[&quot;::0&quot;,&quot;0.0.0.0&quot;],</span><br><span class="line">   &quot;server_port&quot;:your_server_port,</span><br><span class="line">   &quot;password&quot;:&quot;your_password&quot;,</span><br><span class="line">   &quot;timeout&quot;:300,</span><br><span class="line">   &quot;user&quot;:&quot;user&quot;,</span><br><span class="line">   &quot;method&quot;:&quot;your_method&quot;,</span><br><span class="line">   &quot;fast_open&quot;:true,</span><br><span class="line">   &quot;nameserver&quot;:&quot;your_nameserver&quot;,</span><br><span class="line">   &quot;mode&quot;:&quot;your_mode&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验配置是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss-server -c /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure><p>配置到 systemd 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start shadowsocks-libev</span><br></pre></td></tr></table></figure><p>开机自启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl enable shadowsocks-libev</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="https://ynogle.github.io/tags/CentOS/"/>
    
    <category term="Shadowsocks-libev" scheme="https://ynogle.github.io/tags/Shadowsocks-libev/"/>
    
  </entry>
  
  <entry>
    <title>转秋水逸冰 Debian 下 libev 一键安装脚本</title>
    <link href="https://ynogle.github.io/2019/05/28/Debian%20%E4%B8%8B%20Shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/"/>
    <id>https://ynogle.github.io/2019/05/28/Debian%20%E4%B8%8B%20Shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</id>
    <published>2019-05-28T09:22:27.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Debian 或 Ubuntu 下一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），使用 libev 和 C 编写，低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。<span id="more"></span></p><hr><p>本脚本适用环境：<br>系统支持：Debian&#x2F;Ubuntu<br>内存要求：≥128M<br>更新日期：2018 年 06 月 01 日</p><p>关于本脚本：<br>Debian 或 Ubuntu 下一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），使用 libev 和 C 编写，低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</p><p>友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。</p><p>默认配置：<br>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）</p><p>Shadowsocks for Windows 客户端下载：<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>使用方法：<br>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate -O shadowsocks-libev-debian.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev-debian.sh</span><br><span class="line">$ <span class="built_in">chmod</span> +x shadowsocks-libev-debian.sh</span><br><span class="line">$ ./shadowsocks-libev-debian.sh 2&gt;&amp;1 | <span class="built_in">tee</span> shadowsocks-libev-debian.log</span><br></pre></td></tr></table></figure><p>安装完成后，脚本提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, Shadowsocks-libev server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/357.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>卸载方法：<br>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./shadowsocks-libev-debian.sh uninstall</span><br></pre></td></tr></table></figure><p>安装完成后即已后台启动 Shadowsocks-libev ，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><p>可以查看进程是否启动。<br>本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。</p><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">启动：</span><br><span class="line">$ /etc/init.d/shadowsocks start</span><br><span class="line"></span><br><span class="line">停止：</span><br><span class="line">$ /etc/init.d/shadowsocks stop</span><br><span class="line"></span><br><span class="line">重启：</span><br><span class="line">$ /etc/init.d/shadowsocks restart</span><br><span class="line"></span><br><span class="line">查看状态：</span><br><span class="line">$ /etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure><p>配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;server&quot;:[&quot;::0&quot;,&quot;0.0.0.0&quot;],</span><br><span class="line">   &quot;server_port&quot;:your_server_port,</span><br><span class="line">   &quot;password&quot;:&quot;your_password&quot;,</span><br><span class="line">   &quot;timeout&quot;:300,</span><br><span class="line">   &quot;user&quot;:&quot;user&quot;,</span><br><span class="line">   &quot;method&quot;:&quot;your_method&quot;,</span><br><span class="line">   &quot;fast_open&quot;:true,</span><br><span class="line">   &quot;nameserver&quot;:&quot;your_nameserver&quot;,</span><br><span class="line">   &quot;mode&quot;:&quot;your_mode&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验配置是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss-server -c /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure><p>配置到 systemd 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start shadowsocks-libev</span><br></pre></td></tr></table></figure><p>开机自启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl enable shadowsocks-libev</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Debian 或 Ubuntu 下一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），使用 libev 和 C 编写，低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="Shadowsocks-libev" scheme="https://ynogle.github.io/tags/Shadowsocks-libev/"/>
    
    <category term="Debian/Ubuntu" scheme="https://ynogle.github.io/tags/Debian-Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>利用 crontabs 实现定时任务</title>
    <link href="https://ynogle.github.io/2019/04/09/%E5%88%A9%E7%94%A8%20crontabs%20%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://ynogle.github.io/2019/04/09/%E5%88%A9%E7%94%A8%20crontabs%20%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2019-04-09T09:59:12.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用 crontabs 实现定时任务<span id="more"></span></p><hr><h3 id="Debain-环境使用："><a href="#Debain-环境使用：" class="headerlink" title="Debain 环境使用："></a>Debain 环境使用：</h3><h4 id="安装-php-curl（php-脚本需要，非必须）"><a href="#安装-php-curl（php-脚本需要，非必须）" class="headerlink" title="安装 php-curl（php 脚本需要，非必须）"></a>安装 php-curl（php 脚本需要，非必须）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install php php-curl</span><br></pre></td></tr></table></figure><h4 id="编辑-crontab-文件："><a href="#编辑-crontab-文件：" class="headerlink" title="编辑 crontab 文件："></a>编辑 crontab 文件：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><h4 id="然后按照以下规则填写要执行的任务："><a href="#然后按照以下规则填写要执行的任务：" class="headerlink" title="然后按照以下规则填写要执行的任务："></a>然后按照以下规则填写要执行的任务：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,w        ed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  *   user-name  command to be executed</span></span><br><span class="line">  分 时 天  月 星期 执行的用户   执行的命令</span><br></pre></td></tr></table></figure><h4 id="最后，重启-crontab："><a href="#最后，重启-crontab：" class="headerlink" title="最后，重启 crontab："></a>最后，重启 crontab：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service cron restart</span><br></pre></td></tr></table></figure><hr><h3 id="Centos-环境使用："><a href="#Centos-环境使用：" class="headerlink" title="Centos 环境使用："></a>Centos 环境使用：</h3><h4 id="安装-crontabs（已安装的略过）"><a href="#安装-crontabs（已安装的略过）" class="headerlink" title="安装 crontabs（已安装的略过）"></a>安装 crontabs（已安装的略过）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install crontabs</span><br></pre></td></tr></table></figure><h4 id="编辑任务列表"><a href="#编辑任务列表" class="headerlink" title="编辑任务列表"></a>编辑任务列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/crontab</span><br></pre></td></tr></table></figure><h4 id="加载任务-使之生效"><a href="#加载任务-使之生效" class="headerlink" title="加载任务,使之生效"></a>加载任务,使之生效</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab /etc/crontab</span><br></pre></td></tr></table></figure><h4 id="查看任务"><a href="#查看任务" class="headerlink" title="查看任务"></a>查看任务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设为开机启动</span><br><span class="line">$ systemctl <span class="built_in">enable</span> crond</span><br><span class="line"></span><br><span class="line">启动crond服务</span><br><span class="line">$ systemctl start crond</span><br><span class="line"></span><br><span class="line">查看状态</span><br><span class="line">$ systemctl status crond</span><br></pre></td></tr></table></figure><h4 id="其他高级用法请自行搜索。"><a href="#其他高级用法请自行搜索。" class="headerlink" title="其他高级用法请自行搜索。"></a>其他高级用法请自行搜索。</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用 crontabs 实现定时任务</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="Centos" scheme="https://ynogle.github.io/tags/Centos/"/>
    
    <category term="Nginx," scheme="https://ynogle.github.io/tags/Nginx/"/>
    
    <category term="crontab" scheme="https://ynogle.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>优化 Android Studio 构建速度</title>
    <link href="https://ynogle.github.io/2018/09/21/%E4%BC%98%E5%8C%96%20Android%20Studio%20%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"/>
    <id>https://ynogle.github.io/2018/09/21/%E4%BC%98%E5%8C%96%20Android%20Studio%20%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</id>
    <published>2018-09-21T06:43:38.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发中，小伙伴们一直在抱怨：“项目运行好卡啊~”。但是由于项目跟的一直很紧，一直都没有时间专心的去查找项目运行卡的原因。直到现在，终于有闲工夫来看看到底是什么原因引起的。<span id="more"></span>于是，就去 google 上搜了大半天。试了各种偏方、正方。依旧没有解决这个疑难杂症。</p><hr><p>就在要弃疗的时候，在 Android Developers 上面看到了一句话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 配置 org.gradle.jvmargs 时，如果您将 javaMaxHeapSize 设为 1280 MB，</span><br><span class="line">则必须将 org.gradle.jvmargs 至少设置为 1792 MB (1280 + 512)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>忽然想起来，项目中在 dexOptions 中配置了 javaMaxHeapSize &#x3D; “4g”，但是在<br>gradle.properties 中 org.gradle.jvmargs&#x3D;-Xmx1536m 却只配置了 1536m。WTF 啊，你给我配置了 4g，却把我放在了 2g 多一点的空间里，GC 一直频繁地清理内存。不卡才是见鬼了！</p><p>接下来就好办了，开始配置吧：</p><p>说明一下，以下配置的数值需要按照自己在项目中的需求来调整。</p><ol start="0"><li>如有需要先来配置一下 app&#x2F;build.gradle 下的 dexOptions ：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaMaxHeapSize = 1280m</span><br></pre></td></tr></table></figure><ol><li>然后再配置一下 gradle.properties ：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1280</span>(javaMaxHeapSize) + <span class="number">512</span></span><br><span class="line">org.gradle.jvmargs=-Xmx1792m</span><br></pre></td></tr></table></figure><ol start="2"><li>最后还需要配置一下 Android Studio 的 studio.vmoptions 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最小堆内存 我配置的是 1024m</span><br><span class="line">-Xms1024m</span><br><span class="line">最主要的是这个最大堆内存，至少要与配置项目中 org.gradle.jvmargs 相同，当然越大越好</span><br><span class="line">-Xmx1792m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然官网还有一些其他的优化选项，通过整理之后大概是这样：</p><ol start="0"><li>首先在 app&#x2F;build.gradle 中添加以下配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">/* 优化构建速度 */</span></span><br><span class="line">    <span class="keyword">if</span> (project.hasProperty(<span class="string">&#x27;devBuild&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 关闭 multi-APK */</span></span><br><span class="line">        <span class="comment">// 关闭 abi 拆分</span></span><br><span class="line">        splits.abi.enable <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 关闭 density 拆分</span></span><br><span class="line">        splits.density.enable <span class="literal">false</span></span><br><span class="line">        <span class="comment">/* 停用 PNG 处理 */</span></span><br><span class="line">        aaptOptions.cruncherEnabled <span class="literal">false</span></span><br><span class="line">        <span class="comment">/* 停用 Crashlytics */</span></span><br><span class="line">        buildTypes.debug.ext.enableCrashlytics = <span class="literal">false</span></span><br><span class="line">        <span class="comment">/* 停用 Crashlytics 更新 Id */</span></span><br><span class="line">        buildTypes.debug.ext.alwaysUpdateBuildId = <span class="literal">false</span></span><br><span class="line">        <span class="comment">/* 预 dex 库依赖项 */</span></span><br><span class="line">        dexOptions.preDexLibraries <span class="literal">true</span></span><br><span class="line">        <span class="comment">/* 配置运行 dex-in-process 时要使用的最大线程数量 */</span></span><br><span class="line">        dexOptions.maxProcessCount <span class="number">8</span></span><br><span class="line">        <span class="comment">/* 设置最小 Api 为 21 */</span></span><br><span class="line">        defaultConfig.minSdkVersion <span class="number">21</span></span><br><span class="line">        <span class="comment">/* 只打包指定资源 */</span></span><br><span class="line">        defaultConfig.resConfigs (<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;xxhdpi&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>然后在 Android Studio -&gt; Preferences -&gt; Build, Execution, Deployment 下的 Compiler 中的 Command-line Options: 选项中填写：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-PdevBuild</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者可以用 Terminal 敲命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew app:assembleDebug -PdevBuild</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两种方式效果是一样的</p><p>通过以上配置以后，原本编译的时候还能玩会儿手机（几分钟），现在（一分钟以内）。。。我发现好像做了什么不该做的事，还是退回去吧。对不起，打扰了~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在项目开发中，小伙伴们一直在抱怨：“项目运行好卡啊~”。但是由于项目跟的一直很紧，一直都没有时间专心的去查找项目运行卡的原因。直到现在，终于有闲工夫来看看到底是什么原因引起的。</summary>
    
    
    
    <category term="Android" scheme="https://ynogle.github.io/categories/Android/"/>
    
    
    <category term="tools" scheme="https://ynogle.github.io/tags/tools/"/>
    
    <category term="Android" scheme="https://ynogle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>VPS 禁止被 ping</title>
    <link href="https://ynogle.github.io/2016/10/13/VPS%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%A6%81%E6%AD%A2%E8%A2%ABping/"/>
    <id>https://ynogle.github.io/2016/10/13/VPS%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%A6%81%E6%AD%A2%E8%A2%ABping/</id>
    <published>2016-10-13T01:17:48.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上找到的方法很多，但是好多都不能用。在这里记录一下自己在使用的临时禁 ping 和永久禁 ping 的方法。<span id="more"></span></p><hr><h2 id="临时禁-ping-的方法"><a href="#临时禁-ping-的方法" class="headerlink" title="临时禁 ping 的方法"></a>临时禁 ping 的方法</h2><p>有时我们可能由于不希望永久的禁止 ping ，那么，可以通过配置临时的禁止，临时禁 ping 在重启之后会失效。</p><h3 id="禁止"><a href="#禁止" class="headerlink" title="禁止"></a>禁止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">或</span><br><span class="line">$ sysctl -w net.ipv4.icmp_echo_ignore_all = 1</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">或</span><br><span class="line">$ sysctl -w net.ipv4.icmp_echo_ignore_all = 0</span><br></pre></td></tr></table></figure><p>PS ：在我的Centos 7 下，直接修改文件会提示无法修改，而且修改文件的访问权限也是无法修改。不知道是不是个例。</p><h2 id="永久禁-ping-的方法"><a href="#永久禁-ping-的方法" class="headerlink" title="永久禁 ping 的方法"></a>永久禁 ping 的方法</h2><p>也许，有人会觉得每次重启都要去执行一次命令很麻烦（临时禁 ping 的方法），那么，可以使用本方法来实现。</p><p>编辑 &#x2F;etc 下的 sysctl.conf 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>在文件中添加</p><blockquote><p>net.ipv4.icmp_echo_ignore_all&#x3D;1</p></blockquote><p>使文件立刻修改生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /sbin/sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;网上找到的方法很多，但是好多都不能用。在这里记录一下自己在使用的临时禁 ping 和永久禁 ping 的方法。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="Centos" scheme="https://ynogle.github.io/tags/Centos/"/>
    
    <category term="VPS" scheme="https://ynogle.github.io/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 安装、配置 Nginx</title>
    <link href="https://ynogle.github.io/2016/05/03/CentOS7%20Nginx%E9%85%8D%E7%BD%AE/"/>
    <id>https://ynogle.github.io/2016/05/03/CentOS7%20Nginx%E9%85%8D%E7%BD%AE/</id>
    <published>2016-05-03T01:11:09.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同 engine x ）是一个异步框架的 Web 服务器，也可以用作反向代理，负载平衡器和 HTTP 缓存。Nginx 的编写有一个明确目标就是超越 Apache Web 服务器的性能。<span id="more"></span></p><hr><p>下面就开始配置一个自己的 Nginx 服务器吧</p><p><strong><font color=blue>注意：以下命令都是在 root 账户下操作（或每条命令前加上 sudo ）！！！</font></strong></p><h2 id="安装、配置-Nginx"><a href="#安装、配置-Nginx" class="headerlink" title="安装、配置 Nginx"></a>安装、配置 Nginx</h2><h3 id="更新内核、软件"><a href="#更新内核、软件" class="headerlink" title="更新内核、软件"></a>更新内核、软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y update</span><br></pre></td></tr></table></figure><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install nginx</span><br></pre></td></tr></table></figure><h3 id="yum-安装和源安装的区别："><a href="#yum-安装和源安装的区别：" class="headerlink" title="yum 安装和源安装的区别："></a>yum 安装和源安装的区别：</h3><ol><li><p>安装途径：</p><ul><li>yum 安装：简单快捷，不易出错，适合小白。</li><li>源安装：操作复杂，容易出错，适合大神。</li></ul></li><li><p>安装路径：</p><ul><li>yum 安装：文件放在系统的不同位置，卸载时相对会麻烦一些。</li><li>源安装：所有的文件都在一个文件夹，卸载直接删文件夹就行。</li></ul></li><li><p>启动方式：</p><ul><li><p>yum 安装：我们可以通过系统服务命令 service 来启动、停止或重启</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx start|stop|restart # 启动|停止|重启</span><br></pre></td></tr></table></figure></li><li><p>源安装：不能使用 service 来启动，需要执行 nginx 安装目录下的 sbin 目录下的 nginx 可执行程序才行（通常放在 &#x2F;usr&#x2F;local&#x2F;包名）</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/nginx/sbin/nginx # 启动</span><br><span class="line"></span><br><span class="line">$ /usr/local/nginx/sbin/nginx -s stop # 停止</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置-Nginx（-以-yum-安装为例-）"><a href="#配置-Nginx（-以-yum-安装为例-）" class="headerlink" title="配置 Nginx（**以 yum 安装为例**）"></a>配置 Nginx（**<font color=blue>以 yum 安装为例</font>**）</h3><p>进入到 nginx 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/nginx/</span><br></pre></td></tr></table></figure><p>其中 nginx.conf 是全局配置文件，建议自己的配置文件放在 conf.d 文件夹里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation:  http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes 1; # 根据自己主机核数设定，也可以不动</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    server_tokens    off;</span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    # include conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf; # 匹配yours.conf等配置文件路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>配置自己的 conf 文件，以 yours.conf 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim yours.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80 default_server; # default_server nginx 默认访问的域名，只能有一个</span><br><span class="line">listen[::]:80 default_server; # 同上</span><br><span class="line">server_name  www.nginx.com;</span><br><span class="line"></span><br><span class="line"># Load configuration files for the default server block.</span><br><span class="line">location / &#123;</span><br><span class="line">root/yours/;</span><br><span class="line">indexindex.html;</span><br><span class="line"> allow all; # 有多个域名时，需要分发不同的端口，具体配置 Google 搜索。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /40x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx（发音同 engine x ）是一个异步框架的 Web 服务器，也可以用作反向代理，负载平衡器和 HTTP 缓存。Nginx 的编写有一个明确目标就是超越 Apache Web 服务器的性能。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="Centos" scheme="https://ynogle.github.io/tags/Centos/"/>
    
    <category term="Nginx" scheme="https://ynogle.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 配置SSH端口</title>
    <link href="https://ynogle.github.io/2016/03/09/CentOS7%20%E4%BF%AE%E6%94%B9SSH%E7%AB%AF%E5%8F%A3/"/>
    <id>https://ynogle.github.io/2016/03/09/CentOS7%20%E4%BF%AE%E6%94%B9SSH%E7%AB%AF%E5%8F%A3/</id>
    <published>2016-03-09T01:09:34.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时，我们为了降低服务器被攻击的几率，需要通过限制开放的端口号来起到保护作用（虽然没什么卵用）。</p><p>国内的服务器商还好，有可视化的界面来操作，使用起来也很方便。但是，对于某些服务商来说需要通过命令行操作防火墙，这对于小白来说简直就是天书，脑仁疼啊。所以，写了这篇文章来记录。<span id="more"></span></p><hr><p>下面就用更改ss的端口为例</p><p><strong><font color=blue>注意：以下命令都是在 root 账户下操作（或每条命令前加上 sudo ）！！！</font></strong></p><h2 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><h3 id="启动防火墙-查看防火墙状态"><a href="#启动防火墙-查看防火墙状态" class="headerlink" title="启动防火墙 &amp;&amp; 查看防火墙状态"></a>启动防火墙 &amp;&amp; 查看防火墙状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line">$ systemctl start firewalld</span><br><span class="line">$ systemctl status firewalld</span><br></pre></td></tr></table></figure><p>到这里，防火墙就已经启动了。</p><h3 id="激活-public-区域，增加网卡接口"><a href="#激活-public-区域，增加网卡接口" class="headerlink" title="激活 public 区域，增加网卡接口"></a>激活 public 区域，增加网卡接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --set-default-zone=public</span><br><span class="line">$ firewall-cmd --zone=public --add-interface=eth0</span><br></pre></td></tr></table></figure><h3 id="为-public-区域永久开放-26400-TCP-端口"><a href="#为-public-区域永久开放-26400-TCP-端口" class="headerlink" title="为 public 区域永久开放 26400&#x2F;TCP 端口"></a>为 public 区域永久开放 26400&#x2F;TCP 端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --permanent --zone=public --add-port=46000/tcp</span><br></pre></td></tr></table></figure><h3 id="重起防火墙"><a href="#重起防火墙" class="headerlink" title="重起防火墙"></a>重起防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="查看当前暴露端口规则"><a href="#查看当前暴露端口规则" class="headerlink" title="查看当前暴露端口规则"></a>查看当前暴露端口规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --permanent --list-port</span><br><span class="line">$ firewall-cmd --zone=public --list-all</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><h3 id="重启配置文件"><a href="#重启配置文件" class="headerlink" title="重启配置文件"></a>重启配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart sshd</span><br></pre></td></tr></table></figure><h3 id="移除22端口"><a href="#移除22端口" class="headerlink" title="移除22端口"></a>移除22端口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --permanent --zone=public --remove-port=22/tcp</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时，我们为了降低服务器被攻击的几率，需要通过限制开放的端口号来起到保护作用（虽然没什么卵用）。&lt;/p&gt;
&lt;p&gt;国内的服务器商还好，有可视化的界面来操作，使用起来也很方便。但是，对于某些服务商来说需要通过命令行操作防火墙，这对于小白来说简直就是天书，脑仁疼啊。所以，写了这篇文章来记录。</summary>
    
    
    
    <category term="Linux" scheme="https://ynogle.github.io/categories/Linux/"/>
    
    
    <category term="Centos" scheme="https://ynogle.github.io/tags/Centos/"/>
    
    <category term="防火墙" scheme="https://ynogle.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="端口" scheme="https://ynogle.github.io/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ynogle.github.io/2016/01/21/hello-world/"/>
    <id>https://ynogle.github.io/2016/01/21/hello-world/</id>
    <published>2016-01-21T01:37:55.000Z</published>
    <updated>2020-08-23T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.</summary>
    
    
    
    <category term="新手村" scheme="https://ynogle.github.io/categories/%E6%96%B0%E6%89%8B%E6%9D%91/"/>
    
    
    <category term="hexo" scheme="https://ynogle.github.io/tags/hexo/"/>
    
    <category term="site" scheme="https://ynogle.github.io/tags/site/"/>
    
  </entry>
  
</feed>
